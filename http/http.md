
# http

### 为什么要进行URI编码

* 传递数据中，如果存在 `用作分隔符的保留字符` 怎么办？
* 对可能`产生歧义性的数据`编码
    * 不在ASCII码范围内的字符
    * ASCII码中不可显示的字符 （一共128个、33个无法显示 99个可以显示）
    * URI中规定的保留字符
    * 不安全字符(传输环节中可能会被不正确处理)，如空格、引号、尖括号等；

* URI中规定的保留字符：
    * gen-delims -- : / ? # [ ] @
    * sub-delims -- ! $ & ' ( ) * + , ; =
* URI 百分号编码
    * 百分号编码方式
        * % HEXDIG HEXDIG
        * 对于HEXDIG 十六进制中的字母，大小写等价
    * 非ASCII码字符（例如中文）：建议先UTF-8编码，在US-ASCII编码；
    * 对于URI合法字符，编码与不编码是等价的
    
### 请求行
* `request-line = method SP request-target SP HTTP-version CRLF`
* method方法：指明操作目的，动词;
* request-target:如果为OPTIONS方法传递"*";
* Http-version
    * HTTP/0.9:只支持GET方法，过时；
    * HTTP/1.0:RFC1945，1996 (常见与代理服务器)
    * HTTP/1.1:RFC2616 ，1999
    * HTTP/2.0:2015.5正式发布

### CORS(跨域资源共享)
* Preflighted Requests(预检请求)
Preflighted Requests是CORS中一种透明 `服务器验证机制`,预检请求首先需要向另外一个域名的资源发送一个 `HTTP OPTIONS 请求头`，其目的就是为了判断`实际发送的请求是否是安全的`。
* 下面的2种情况需要进行预检：
    * 简单请求，比如使用Content-Type 为 application/xml 或 text/xml 的 POST 请求；
    * 设置自定义头，比如 X-JSON、X-MENGXIANHUI 等。

### 运输层协议（TCP、UDP）：
* 进程之间通信 -- 向上面的应用层提供通信服务；
* 为`应用进程之间`提供`端到端`的逻辑通信；
* 向高层用户屏蔽了下面网络核心细节(网络拓扑、所采用的路由选择协议等)；
* 复用（multiplexing）：发送方 不同的应用进程都可以使用同一个运输协议传送数据；
* 分用(demultiplexing)：接收方 的运输层在`剥去报文的首部`后能够把这些数据正确交付目的应用进程；

### TCP (传输控制协议 Transmission Control Protocol)
* 特点：
    * 提供面向连接服务(在传送数据前必须建立连接)
    * TCP不提交广播或者多播服务；
    * TCP提供可靠交付的服务。（无差错、不丢失、不重复、并且安全按序到达）。
    * TCP提过全双工通信。
        * 允许通信双方的应用进程在任何时候都能发送数据。
        * TCP连接的两端都设有`发送缓存`和`接收缓存`，用来临时存放双向通信的数据；
    * 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）。
        TCP端点：套接字或者插口。（端口号拼接到IP地址--构成套接字）
    * 面向字节流（流：流入到进程或者从进程流出的`字节序列`）；
        * 把数据看成一连串的无结构字节流;
        * TCP不关心应用进程一次把多长的报文发送给TCP缓存中,而是根据对方给出的窗口值和当前网络拥塞的程度决定一个报文段应包含多少个字节。


1. TCP握手过程：


2. TCP挥手过程：

3. TCP缺点：
    * TCP可能会`间歇性`地`挂起数据传输`；
        * 如果一个序列号较低的数据段还没有接收到，即使其他序列号较高的段已经接收到，TCP的接收机滑动窗口也不会继续处理。这将导致`TCP流 瞬间挂起`，在更糟糕的情况下，即使所有的段中有一个没有收到，也会导致关闭连接。这个问题被称为TCP流的行头阻塞（HoL）。
    * TCP不支持`流级复用`
        * 虽然TCP确实允许在应用层之间建立多个逻辑连接，但它不允许在`一个TCP流中复用数据包`。使用HTTP/2时，浏览器只能与服务器打开一个TCP连接，并使用同一个连接来请求多个对象，如CSS、JavaScript等文件。在接收这些对象的同时，TCP会将所有对象序列化在同一个流中。因此，它不知道TCP段的对象级分区。
    * TCP会`产生冗余通信`
        * TCP连接握手会有冗余的消息交换序列，即使是与已知主机建立的连接也是如此。

### UDP (用户数据报协议 User Datagram Protocol)
* 特点：
    1. UDP是无连接，在发送数据之前不需要建立连接;
    2. UDP使用尽最大努力交付，不保证可靠交付，主机之间不需要维护负责的连接状态；
    3. UDP面向报文；
        * 发送方的UDP对 应用程序交下拉的报文，在添加首部后就向下交付IP层。
        * UDP对应用层交下来的报文，即不合并也不拆分，而是保留报文的边界。
        * 应用层交给UDP多长的报文，UDP照样发送，一次发送一个报文（一次交付一个完整的报文）。
        * 应用程序必须选择合适大小的报文，报文太长，UDP交给IP层后，IP层在传送时，可能要进行分片，这会降低IP层的效率；报文太短，IP数据报的首部相对长度太长，也降低IP层效率；
    4. 无拥塞控制
        * 网络出现的拥塞不会影响源主机的发送效率降低；
    5. UDP支持一对一，一对多，多对一，多对多的交互通信；
    6. UDP首部开销小(只有8字节，比TCP20字节首部要短)
    7. 在不影响实时性的前提下，增加一些提高可靠传输性的措施(前向纠错、重传已丢失的报文)；

### TCP与 UDP区别
* TCP面向连接(三次握手)的服务,UDP在发送数据之前不需要建立连接；
* TCP提供可靠服务.通过TCP连接传送的数据，`无差错，不丢失，不重复`，且`按序到达`;UDP尽最大努力交付，即不保证可靠交付.
* TCP有拥塞控制。UDP没有拥塞控制，因此`网络出现拥塞不会使源主机的发送速率降低`（对实时应用很有用，如IP电话，实时视频会议等）
* 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信;
* TCP首部开销20字节;UDP的首部开销小，只有8个字节;
* TCP的`逻辑通信信道`是全双工的可靠信道，UDP则是不可靠信道;

### TCP的流量控制 （点对点通信量的控制  --抑制发送端的发送数据的速率）
* 利用滑动窗口实现
    * (一般情况，总希望数据传输的更快点，但是如果发送方 把数据发送的过快，接收方来不及接收，这就造成数据的丢失)。
    * 流量控制(flow control)：让发送方的`发送速率`不要太快，要让接收方来得及接收；(控制发送速率)
    * 利用滑动窗口机制实现 在TCP连接上实现 对发送方的流量控制；
    * TCP窗口单位字节（不是报文段）；
    * 在连接建立时，B告诉A“接收窗口 rwnd=400 rwnd“receiver window”,发送方的发送窗口不能超过接收方给的接收窗口的数量；
    * 考虑一种情况（零窗口 -- 死锁局面）。 -- 解决办法持续计时器
        * TCP为每一连接设有一个`持续计时器`(persistence timer);
        * 只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。
        * 若持续计时器设置的时间到期，就发送一个零窗口探测报文段(仅1字节的数据)，对方在确认这个探测报文段时给出一个现在的窗口值。
        * 如果还是零，那么重新设置持续计时器；
        * 如果不为零，打破死锁局面；

### TCP拥塞控制
* 目的：使网络中的路由器和链路不致过载；
* 前提：网络能够承载现有的网络负荷；
* 拥塞控制是一个全局性过程；
* 拥塞控制的方法(4种)
    * 慢启动(指数增长)
        * 当主机开始发送数据时，如果立即把大量数据字节注入到网络，有可能引起网络拥塞。（刚开始不清楚网络的负载情况）--先探测（由小到大逐渐增大发送窗口(拥塞窗口)）。cwnd
    * 拥塞避免（线性规律缓慢增加）
        * 让拥塞窗口缓慢增大。每经过一个RTT就把发送方的拥塞窗口(cwnd)加1,而不是加倍。
    * 快重传
    * 快恢复

### 参考文献
[Http 1.x弊端与Http 2.0比较](https://www.cnblogs.com/barrywxx/p/8570006.html)

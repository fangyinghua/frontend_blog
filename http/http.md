
# http

### 为什么要进行URI编码

* 传递数据中，如果存在 `用作分隔符的保留字符` 怎么办？
* 对可能`产生歧义性的数据`编码
    * 不在ASCII码范围内的字符
    * ASCII码中不可显示的字符 （一共128个、33个无法显示 99个可以显示）
    * URI中规定的保留字符
    * 不安全字符(传输环节中可能会被不正确处理)，如空格、引号、尖括号等；

* URI中规定的保留字符：
    * gen-delims -- : / ? # [ ] @
    * sub-delims -- ! $ & ' ( ) * + , ; =
* URI 百分号编码
    * 百分号编码方式
        * % HEXDIG HEXDIG
        * 对于HEXDIG 十六进制中的字母，大小写等价
    * 非ASCII码字符（例如中文）：建议先UTF-8编码，在US-ASCII编码；
    * 对于URI合法字符，编码与不编码是等价的
### 请求行
* `request-line = method SP request-target SP HTTP-version CRLF`
* method方法：指明操作目的，动词;
* request-target:如果为OPTIONS方法传递"*";
* Http-version
    * HTTP/0.9:只支持GET方法，过时；
    * HTTP/1.0:RFC1945，1996 (常见与代理服务器)
    * HTTP/1.1:RFC2616 ，1999
    * HTTP/2.0:2015.5正式发布
### 常见方法
幂等方法：是指无论调用多少次,结果都相同; --事务
* GET：获取信息，幂等方法；
* HEAD:类似GET，但是服务器不发送BODY，用于获取HEAD元数据，幂等方法；
* POST：新增资源；常用于提交HTML form表单；
* PUT：更新资源，带条件时是幂等方法;
* DELETE:删除资源，幂等方法；
* CONNECT：建立tunnel隧道；
* OPTIONS：显示服务器对访问资源支持 的方法，幂等方法；（跨域）
    * 检测服务器性能
    * 获取服务器支持的的HTTP请求方法；
* TRACE：回显服务器收到的请求，用于定位问题。有安全风险；

### CORS(跨域资源共享)
* Preflighted Requests(预检请求)
Preflighted Requests是CORS中一种透明 `服务器验证机制`,预检请求首先需要向另外一个域名的资源发送一个 `HTTP OPTIONS 请求头`，其目的就是为了判断`实际发送的请求是否是安全的`。
* 下面的2种情况需要进行预检：
    * 简单请求，比如使用Content-Type 为 application/xml 或 text/xml 的 POST 请求；
    * 设置自定义头，比如 X-JSON、X-MENGXIANHUI 等。

### 响应码
* 1XX:请求已接收到，需要进一步处理才能完成，http1.0不支持；
    * 100 Continue:上传大文件前使用（告知服务器需要上传大文件）
        * 由客户端发起请求中携带 Expect：100-continue 头部触发 （Expect预期）
        * 服务器返回 100 Continue
    * 101 Switch Protocols:协议升级使用
        * 由客户端发起请求中携带Upgrade头部触发；
    * 102 Processing(处理)：表示服务器已经收到并正在处理请求，但无响应可用(处理响应要很久)，防止客户端超时。

* 2XX：
    * 200 ok:成功返回响应;
    * 201 Created：有新资源在服务器端被成功创建;
    * 202 Accepted:服务端接收并开始处理请求，但请求未处理完成。例如：异步、需要长时间处理的任务。
    * 204 No Content:成功执行了请求且不携带响应包体，并暗示客户端无需更新当前的页面视图；
    * 205 Reset Content:成功执行了请求且不携带响应包体，并暗示客户端需更新当前的页面视图；
    * 206 Partial Content:使用range协议时返回部分响应内容时的响应码；

* 3XX：重定向使用Location指向的资源或者缓存中的资源。在RFC2068中规定客户端重定向次数不超过5次，以防止死循环。
    * 301 moved premanentle:资源永久性的重定向到另一个URI中；
    * 302 Found:资源临时的重定向到另一个URI中；
    * 304 not modified：告知客户端可以复用缓存。

* 4XX: （400 401/407 405 408 411 413/414 415）
    * 400 bad request:服务器认为客户端出现了错误，但不能明确判断为以下那种错误时使用此错误码。例如http请求格式错误。

    * 401 unauthorized:用户认证信息缺失或者不正确，导致服务器无法处理请求。（源服务器返回）
    * 407 Proxy authentication required:认证信息未通过代理服务器的验证(代理服务器返回)
    
    * 403 Forbidden：服务器理解`请求的含义`，但是没有权限执行此请求。

    * 404 not found:服务器没有找到对应的资源；
    * 410 Gone:对404补充，知道资源永远没有此资源；

    * 405 method Not allowed：服务器不支持请求行中的method方法
    * 408 request timeout：服务器`接收请求`超时

    * 411 length required:如果请求含有包体且未携带content-length头部，且不属于chunk类请求时。

    * 413 payload too large：请求的包体超出服务器能处理的最大长度
    * 414 URI too long：请求的URI超出服务器能接受的最大长度；
    

    * 415 unsupported media type：上传的文件类型不被服务器支持；
    * 451：由于法律原因资源不可访问

* 5xx （500 502 504 511）
    * 500：服务器内部错误，且不属于一下错误类型；
    * 501 not implemented:服务器不支持实现请求所需要的功能；
    * 502 bad Gateway：代理服务器无法（从源服务器）获取到合法响应；
    * 503 service unavailable:服务器(并发数达到上限等原因)资源尚未准备好 处理当前请求；
    * 504 gateway timeout：代理服务器无法及时的从上游获取响应；（代理服务器设置的超时时间太短了）
    * 505 http version not supported ：请求使用的http协议版本不支持；
    * 511 network authentication required：代理服务器发现客户端需要进行 身份验证才能获得网络访问权限；

###  http发展历程
* 早在 HTTP 建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器，用户端通过浏览器访问url地址来获取网页的显示内容。
* 到了 WEB2.0 以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的 HTML 页面有了 CSS，Javascript，来丰富我们的页面展示，当 ajax 的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于 HTTP 协议的。

1. http0.9
    使用“GET”方式从服务器获取HTML文档（纯文本格式）,并且在响应请求后立即关闭连接。
2. HTTP1.0 -- 1996年正式发布
    * 增加 HEAD、POST请求方式；(GET/POST/HEAD)
    * 增加响应状态码，标记可能错误的原因
    * 引入协议版本号概念；
    * 引入HTTP header头概念
    * 传输数据不限于文本
3. HTTP1.1 -- 1999年，HTTP1.1发布了RFC文档
    * 增加了 PUT、DELETE请求方法；
    * 增加了缓存管理和控制；
    * 明确了连接管理（默认长连接）;
    * 允许响应数据分块(chunked); --传输大文件
    * 强制要求添加Host头（虚拟主机）--没有Host头,400 Bad Request.

4. http2 -- HTTP/2标准于2015年5月 以RFC 7540正式发表
    * 前身 SPDY,2015年9月，google移除对SPDY的支持，抱 HTTP/2，在Chrome 51中生效；
    * 简称 h2(基于TLS/1.2或以上版本的加密连接) / h2c（非加密连接);
    * 多路复用：将一个TCP连接分为若干个流（Stream），每个流中可以传输若干消息（Message），每个消息由若干最小的二进制帧（Frame）组成。
        * 流：是连接中的一个虚拟信道，可以承载双向的消息；
        * 消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成
        * 帧：客户端与服务器通过`交换帧来通信`，帧是基于这个新协议通信的最小单位。
    * 二进制帧 (http1.x基于文本，文本具有多样性)
    * 头部压缩(HPACK算法)--（Dynamic Table / Huffman Coding）;
    * 设置请求的优先级 
    * 服务端推送 -- 允许服务器直接提供浏览器渲染页面所需资源，而无须浏览器在收到、解析页面后再提起一轮请求，节约了加载时间。
    * 增强了安全性，“事实上”要求加密通信。
5. http3 -- 
    * 选择UDP作为底层传输层协议；
    * 流复用和流控：QUIC引入了连接上的多路流复用的概念。
    * 灵活的拥塞控制机制：更有效地利用可用的网络带宽，从而获得更好的吞吐量
    * 更好的错误处理能力：QUIC使用增强的丢失恢复机制和转发纠错功能，以更好地处理错误数据包。
    * 更快的握手：QUIC使用相同的TLS模块进行安全连接。QUIC的握手机制经过优化.

### http的状态码
* RFC规定状态码：三位数字组成，取值范围000-999;
* RFC把状态码分成5类：用数字的第一位表示分类，这样状态码范围变成100-599；

### cookie (http state management mechanism)
* cookie是http的状态管理机制;
* 保存在客户端、由浏览器维护、表示应用状态的http头部
    * 存放在内存或者磁盘中
    * 服务器端生成cookie在响应中，通过set-cookie头部告知客户端（允许多个set-cookie）
        ```
        set-cookie:key=vaule;
        set-cookie:key2=vaule2;
        ```
    * 客户端得到cookie后，后续请求都会自动将cookie头部携带至请求中
    ```
    cookie:key=vaule;key2=vaule2;
    ```
* cookie-pair的属性(6个)
    `cookie-av=expires-av/max-age-av/domain-av/path-av/secure-av/httponly-av/extension-av`
    * expires-av=“Expires="sane-cookie-date
        * cookie到日期 sane-cookie-date后失效
    * max-age-av="Max-Age="non-zero-digit * DIGIT
        * cookie 经过 *DIGIT秒后失效。max-age优先级高于expires
         `set-cookie:key1=value;path=/;Max-Age=10;`
    * domain-av="Domain="domain-value
        * 指定cookie可用于那些域名，默认可访问当前域名
    * path-av="Path="path-value
        * 指定path路径下才能使用cookie
        `set-cookie:key1=value;path=/`
    * secure-av="Secure"
        * 只有使用TLS/SSL协议时才能使用cookie
    * httponly-av="HttpOnly"
        * 不能使用js的api访问到cookie
         `set-cookie:key1=value;path=/;HttpOnly`

* Cookie 使用限制
    * RFC规范对浏览器使用Cookie的要求
        * 每条cookie的长度至于要达到4KB;
        * 每个域名才至少支持50个Cookie；
        * 至少要支持300个cookie；
    * 代理服务器传递Cookie时会有限制
* Cookie在协议设计上的问题
    * Cookie会被附件到每个http请求中，所以无形增加传输流量
    * 由于http请求中cookie是明文传输，所以完全性成问题；
    * Cookie的大小不应该超过4kB，对复杂的存储需求不够用；
* 第三方Cookie
    浏览器允许对应不安全域下(跨域)的资源（比如：广告、图片） 响应中的set-cookie保存，并在后续访问该域时自动使用cookie；
    * 用户踪迹信息的搜索

### 为什么需要同源策略（协议、主机、端口必须完全相同）
不能保证请求是用户自愿发出的？
* 安全性与可用性需要一个平衡点
    * 可用性：HTML的创作者 决定跨域请求是否对本站点安全；
        * <script><img><iframe><link><video><audio>带有src属性可以跨域访问；
        * 允许跨域 写操作：例如：表单提交或者重定向请求；
            * CSRF安全性问题
    * 安全性：浏览器需要防止站点A的脚本向站点B发起危险动作；
        * Cookie、LocalStorage和indexDB无法读取
        * DOM无法获取
        * Ajax请求不能发送

* 跨站请求伪造攻击（Cross-site request forgery）


### 如何合法跨域请求
* 浏览器同源策略下的跨域访问解决方案
    * 如果站点A允许站点B的脚本访问其资源，必须`在HTTP响应中显式的告知浏览器`：站点B是被允许访问的。
        * 访问站点A的请求，浏览器应告知该请求来自站点B；
        * 站点A的响应中，应明确那些跨域请求是被允许的；
* 策略1：何为简单请求?
    * GET/POST/PUT
    * 

```s
request头
    origin:
响应头：
    Access-Control-Allow-Origin：''
```




CORS（跨域资源共享）


### 运输层协议（TCP、UDP）：
* 进程之间通信 -- 向上面的应用层提供通信服务；
* 为`应用进程之间`提供`端到端`的逻辑通信；
* 向高层用户屏蔽了下面网络核心细节(网络拓扑、所采用的路由选择协议等)；
* 复用（multiplexing）：发送方 不同的应用进程都可以使用同一个运输协议传送数据；
* 分用(demultiplexing)：接收方 的运输层在`剥去报文的首部`后能够把这些数据正确交付目的应用进程；

### TCP (传输控制协议 Transmission Control Protocol)
* 特点：
    * 提供面向连接服务(在传送数据前必须建立连接)
    * TCP不提交广播或者多播服务；
    * TCP提供可靠交付的服务。（无差错、不丢失、不重复、并且安全按序到达）。
    * TCP提过全双工通信。
        * 允许通信双方的应用进程在任何时候都能发送数据。
        * TCP连接的两端都设有`发送缓存`和`接收缓存`，用来临时存放双向通信的数据；
    * 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）。
        TCP端点：套接字或者插口。（端口号拼接到IP地址--构成套接字）
    * 面向字节流（流：流入到进程或者从进程流出的`字节序列`）；
        * 把数据看成一连串的无结构字节流;
        * TCP不关心应用进程一次把多长的报文发送给TCP缓存中,而是根据对方给出的窗口值和当前网络拥塞的程度决定一个报文段应包含多少个字节。


1. TCP握手过程：


2. TCP挥手过程：

3. TCP缺点：
    * TCP可能会`间歇性`地`挂起数据传输`；
        * 如果一个序列号较低的数据段还没有接收到，即使其他序列号较高的段已经接收到，TCP的接收机滑动窗口也不会继续处理。这将导致`TCP流 瞬间挂起`，在更糟糕的情况下，即使所有的段中有一个没有收到，也会导致关闭连接。这个问题被称为TCP流的行头阻塞（HoL）。
    * TCP不支持`流级复用`
        * 虽然TCP确实允许在应用层之间建立多个逻辑连接，但它不允许在`一个TCP流中复用数据包`。使用HTTP/2时，浏览器只能与服务器打开一个TCP连接，并使用同一个连接来请求多个对象，如CSS、JavaScript等文件。在接收这些对象的同时，TCP会将所有对象序列化在同一个流中。因此，它不知道TCP段的对象级分区。
    * TCP会`产生冗余通信`
        * TCP连接握手会有冗余的消息交换序列，即使是与已知主机建立的连接也是如此。

### UDP (用户数据报协议 User Datagram Protocol)
* 特点：
    1. UDP是无连接，在发送数据之前不需要建立连接;
    2. UDP使用尽最大努力交付，不保证可靠交付，主机之间不需要维护负责的连接状态；
    3. UDP面向报文；
        * 发送方的UDP对 应用程序交下拉的报文，在添加首部后就向下交付IP层。
        * UDP对应用层交下来的报文，即不合并也不拆分，而是保留报文的边界。
        * 应用层交给UDP多长的报文，UDP照样发送，一次发送一个报文（一次交付一个完整的报文）。
        * 应用程序必须选择合适大小的报文，报文太长，UDP交给IP层后，IP层在传送时，可能要进行分片，这会降低IP层的效率；报文太短，IP数据报的首部相对长度太长，也降低IP层效率；
    4. 无拥塞控制
        * 网络出现的拥塞不会影响源主机的发送效率降低；
    5. UDP支持一对一，一对多，多对一，多对多的交互通信；
    6. UDP首部开销小(只有8字节，比TCP20字节首部要短)
    7. 在不影响实时性的前提下，增加一些提高可靠传输性的措施(前向纠错、重传已丢失的报文)；

### TCP与 UDP区别
* TCP面向连接(三次握手)的服务,UDP在发送数据之前不需要建立连接；
* TCP提供可靠服务.通过TCP连接传送的数据，`无差错，不丢失，不重复`，且`按序到达`;UDP尽最大努力交付，即不保证可靠交付.
* TCP有拥塞控制。UDP没有拥塞控制，因此`网络出现拥塞不会使源主机的发送速率降低`（对实时应用很有用，如IP电话，实时视频会议等）
* 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信;
* TCP首部开销20字节;UDP的首部开销小，只有8个字节;
* TCP的`逻辑通信信道`是全双工的可靠信道，UDP则是不可靠信道;

### TCP的流量控制 （点对点通信量的控制  --抑制发送端的发送数据的速率）
* 利用滑动窗口实现
    * (一般情况，总希望数据传输的更快点，但是如果发送方 把数据发送的过快，接收方来不及接收，这就造成数据的丢失)。
    * 流量控制(flow control)：让发送方的`发送速率`不要太快，要让接收方来得及接收；(控制发送速率)
    * 利用滑动窗口机制实现 在TCP连接上实现 对发送方的流量控制；
    * TCP窗口单位字节（不是报文段）；
    * 在连接建立时，B告诉A“接收窗口 rwnd=400 rwnd“receiver window”,发送方的发送窗口不能超过接收方给的接收窗口的数量；
    * 考虑一种情况（零窗口 -- 死锁局面）。 -- 解决办法持续计时器
        * TCP为每一连接设有一个`持续计时器`(persistence timer);
        * 只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。
        * 若持续计时器设置的时间到期，就发送一个零窗口探测报文段(仅1字节的数据)，对方在确认这个探测报文段时给出一个现在的窗口值。
        * 如果还是零，那么重新设置持续计时器；
        * 如果不为零，打破死锁局面；

### TCP拥塞控制
* 目的：使网络中的路由器和链路不致过载；
* 前提：网络能够承载现有的网络负荷；
* 拥塞控制是一个全局性过程；
* 拥塞控制的方法(4种)
    * 慢启动(指数增长)
        * 当主机开始发送数据时，如果立即把大量数据字节注入到网络，有可能引起网络拥塞。（刚开始不清楚网络的负载情况）--先探测（由小到大逐渐增大发送窗口(拥塞窗口)）。cwnd
    * 拥塞避免（线性规律缓慢增加）
        * 让拥塞窗口缓慢增大。每经过一个RTT就把发送方的拥塞窗口(cwnd)加1,而不是加倍。
    * 快重传
    * 快恢复

### 参考文献
[Http 1.x弊端与Http 2.0比较](https://www.cnblogs.com/barrywxx/p/8570006.html)

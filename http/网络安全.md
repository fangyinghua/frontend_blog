
### CSP(Content Security Policy)
* 核心思想：网站通过发送一个 CSP 头部，来告诉浏览器什么是被授权执行的与什么是需要被禁止的。
* CSP 的实质就是`白名单`制度，开发者明确告诉客户端，`哪些外部资源可以加载和执行，等同于提供白名单`。
* 它的实现和执行全部由浏览器完成，开发者只需提供配置。
* CSP虽然提供了强大的安全保护，但是他也造成了如下问题：Eval及相关函数被禁用、内嵌的JavaScript代码将不会执行、只能通过白名单来加载远程脚本。

* 例子：
`<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">`


### XSS （Cross Site Scripting）--
    缩写为CSS，但这会与层叠样式表（Cascading Style Sheets，CSS）的缩写混淆。因此，有人将跨站脚本攻击缩写为XSS。

* XSS的原理是：
    攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。
* 类型
    * 反射型、DOM-based (非储存型);
    * 持久性XSS攻击(存储型);
* 反射型XSS
    服务器没有经过正确编码 而是直接使用客户端提供的数据的情况下;

* 过程：
    * A 和 B 表示的是用户和网站正常通信，从 C 开始就是 XSS 攻击的整个流程。
    * 首先：
        * C：黑客向用户发送了一个有恶意脚本的URL。
        * D：用户点击之后且登录了 website 。
        * E：服务器返回了恶意脚本的响应。
        * F：恶意脚本在浏览器执行之后，向黑客已经部署的服务器上发送敏感信息。
        * G：黑客前往黑客服务器获取到用户的敏感信息。
        * H：黑客获取到了用户的敏感信息。
        * I：黑客利用已经获取的敏感信息向 website 发起请求，伪装成用户进行非法操作。以上就是 反射型XSS 的整体攻击环节。
* 防御策略
    * 永远不相信用户的输入，对用户输入的特殊字符串进行转译，针对用户的输入 设置标签白名单；
    * cookie设置HttpOnly,配合token或者验证码；
    * 设置CSP安全策略-可以通过两种方式设置CSP，`一种是meta标签，一种是HTTP响应头Content-Security-Policy`。


### 跨站请求伪造攻击（Cross-site request forgery）
    盗用用户身份发送http请求（购物，转账，偷窥你的个人信息，发送信息等）
* 防御CSRF策略
    * 同源检查
        * 验证origin字段：浏览器自定携带该字段。请求来源域名.IE11在cors请求中不会携带该字段，302重定向也不会携带。
        * 验证referer字段：浏览器自定携带该字段。请求来源uri.依赖浏览器保障，攻击者可以修改；
    * 不使用cookie，使用token（令牌）字段
        * 第三方网站不能获取token信息，浏览器也不会自动添加该请求头。
        * cookie 浏览器会自定添加到该http请求中；
        * 隐藏token令牌(form 添加个input为hidden)，跨域条件下，第三方网站不能获取DOM信息；
    * Samesite cookie （兼容性问题）
        * 禁止该cookie，作为第三方cookie。Samesite值有strict，Lax（只有通过get方法跳转方法才携带cookie）

### 网络传输安全
中间人 (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独立的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过一个私密的连接与对方直接对话, 但事实上整个会话都被攻击者完全控制. 在中间人攻击中, 攻击者可以拦截通讯双方的通话并插入新的内容。

* 防范
    * 对于个人来说防止自己被中间人攻击最基本的就是不要乱连不安全的网络
    * 司APP来说应该配置禁止被抓包
    * APP和浏览器都应该严格校验证书，不使用不安全的APP和浏览器

### 接口加密
参数加密

### 接口加签 （哈希算法）
* 通过上面的例子我们知道https并不是绝对安全的，他是会被中间人劫持的，那么我们有什么方法`防止数据被篡改`呢？接口加签的目的是防止数据被篡改！
* 服务端网关首先会验签，如果签名不对直接拒绝请求，而`签名的生成和请求参数相关`，当接口请求中的参数被篡改后，网关是没法进行验签通过的，直接拒绝了请求，抛出错误。


### 接口防重放
![接口防重放](../../img/http/sec.png)

* 防重放也叫防复用，简单来说,就是我获取到这个请求的信息之后, 我什么也不改, 我就拿着接口的参数去重复请求这个充值的接口，也就是说我的请求是合法的，因为所有参数都是跟合法请求一模一样的，也就是说: 服务端的 sign 验证一定能通过。如图上的例子，即使我们不知道登录账户名密码，即使接口参数被加签加密了，我们依旧能够登录并拿到登录信息，我们根本不用关心加密加签的逻辑，我们只需要简单的重放攻击即可。

* 防重放设计
    * 客户端在请求中添加两个参数 1.1 添加一个随机不重复的字符串参数 比如uuid 至于怎么让他不重复,可以考虑拼接时间戳,md5随机数等 1.2 添加一个请求时间的参数 如 time 值就是发送请求时的 时间戳
    * 服务端接收到请求之后: 2.1 去缓存里中查找 uuid 这个参数对应的值是否存在 2.2 如果不存在: 就把这个uuid的值保存到缓存中, 记录这个请求 2.3 如果已存在: 存在那就证明, 已经请求过一次了, 就不处理这个请求了

这就是最简单的防重放逻辑，接口只能调用一次，即使被中间人攻击后也没法进行重放

### 新型验证码（辨别行为是机器还是人）
新型验证码不仅很难破解，他的交互会更加的友善，甚至做到无验证码，只有在需要进行验证的时候才出来。

### 代码加密混淆
    对于非常核心的业务逻辑代码加密。
* 比如：
    * 前端加签代码，由于加签是在前端进行的，前端必须存有秘钥和加签规则，但是一旦被第三方知道加签的秘钥和规则，加签也就不攻而破了，所以加签的前端代码必须得加密。
    * 新型验证码 用户行为 采集代码，新型验证码涉及很多用户行为的前端采集，然后提交后端分析，如果采集规则被第三方知道，那么攻击者也就很好的进行攻击行为，所以采集代码也是需要加密的。

### DOS 攻击 --造成远程服务器拒绝服务的行为被称为DOS攻击；
* 常见DOS攻击：
    1. 计算机带宽攻击；
    2. 连通性攻击；

* TCP缺陷：
    1. 伪造ACK数据包，希望server重传某些数据包，server根据TCP重传机制，进行数据重传。通过TCP协议缺陷，`发送大量的半连接请求`。



### 参考文献：
[学习前端安全知识防止被偷袭](https://mp.weixin.qq.com/s/p2EQeVNo3VQKruqPJgw--w)

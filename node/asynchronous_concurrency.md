### 异步并发控制

* 同步IO/异步IO：
    1. 同步IO内的任务彼此阻塞(在循环体内一个接着一个执行 --串行执行)，性能低，但是不会出现消耗多<span style="color:red">文件描述符</span>太多问题。
    2. 异步IO容易实现并发，但是并发数不控制，容易出现操作系统的文件描述数量被瞬间耗光，从而导致出错。需要过载保护。

* bagpipe解决思路：
    1. 通过队列来控制并发数；
    2. 如果当前活跃的异步调用量小于限定值，从队列中取出执行。
    3. 如果活跃调用达到限定值，调用暂时存放在队列中。
    4. 每个异步调用结束时，从队列中取出新的异步调用执行。
    5. 由于可能某些异步任务执行时间很久，慢慢如果这种异步任务过多的话，也会达到限制没办法在执行后面的任务，所以引入了超时，将超时的从队列中删除。（某些场景可以使用，比如对实时性有要求的）。
   

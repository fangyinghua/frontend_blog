### Number
1. JS Number数据的储存 基础知识
* javaScript 中所有数字包括整数和小数都只有一种类型 — Number。遵循 IEEE 754 标准，使用 `64 位固定长度`来表示;
* 这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。

* IEEE754 64位双精度浮点数
    * 浮点数：Value= sign * exponent * fraction
        * sign：符号
        * exponent:指数
        * fraction：小数、分数/尾数
* 浮点数的实际值，等于`符号位（sign bit）` 乘以 `指数偏移值(exponent bias)` 再乘以 `分数值(fraction)`。
* 存储结构优点是可以`归一化处理整数和小数`，节省存储空间;

* 符号位S：第 1 位是正负数符号位(sign)，0代表正数，1代表负数;
* 指数位E：中间的 11 位存储指数(exponent)，用来表示次方数;
* 尾数位M：最后的 52 位是尾数(mantissa)，超出的部分自动进一舍零;


* V =(-1)^s * 2^(E-1023) * (M + 1)

* 浮点数
    * exponent
        实际计算机中存储的是经 `偏移的指数`(biased exponent),即在原来指数的基础上加上一个数(`float是加上127，double是1023`)，这个经过偏移的指数一定非负。
    * 存储是统一化成科学记数法，即小数点之前一定是1。
    * 化成科学记数法之后最高位均为1，于是便将1省略，只存储小数点之后的尾数，这种机制使同样的内存空间可以存储更大范围的数。
    * 单精度和双精度所占`字节数`不一样
        * float:exponent(8-bit);
        * double:exponent(11-bit); 指数 E (11位) 0-1022 表示负数，1024-2047表示正数

  
    * 因为指数位E有 11 位，是一个无符号整数，取值范围是 0 到 2047(2047 = Math.pow(2,11)-1)。但是科学计数法中的指数是可以为负数的，所以约定减去一个中间数 1023，[0,1022] 表示为负，[1024,2047] 表示为正。

* Number的最大值与最小值
    * Number.MIN_VALUE  -- Math.pow(2,-51) * Math.pow(2,0-1023);
    * Number.MAX_VALUE -- Math.pow(2,2047-1023)-1; -- 11位指数位 （2**11-1）=2047 ，然后偏移指数 1023;
    * 2**1024 = Infinity

* 比如：4.5 转二进制 -- 100.1 -- 指数的写法( 1.001*2^2 )
    * S=0, E=1025 (1023+2), M=001 (小数点后面的尾数)
* 0.1 解释浮点误差的原因，0.1 转成二进制表示为 0.0001100110011001100(1100循环)，1.100110011001100x2^-4，所以 E=-4+1023=1019；M 舍去首位的1，得到 100110011...。

2. Number的安全数 (在安全范围内是连续的)
    * Number.MAX_SAFE_INTEGER :2**53-1   
    * Number.MIN_SAGE_INTEGER :-2**53-1 
    * 2**53 ==2**53+1 =>true
    * 2** 1024 === Infinity =>true


3. Number的方法
    * Number.isInteger() -- 用来判断给定的参数是否为整数。
    * Number.isSafeInteger()
    * Number.isFinite() -- 用来检测传入的参数是否是一个有穷数
    * Number.isNaN()
    * Number.parseFloat()
    * Number.parseInt()

    * Number.prototype.toExponential()  -- 一个`用幂的形式` (科学记数法) 来表示`Number 对象的字符串`。 小数点后以fractionDigits 提供的值来四舍五入。如果 fractionDigits 参数被忽略了，小数点后的将尽可能用最多的位数来表示该数值。 fractionDigits `介于 0 和 20（包括20）之间`.

    ```JS
    numObj.toExponential(fractionDigits)

    //例子
    4.15.toExponential(1)
    "4.2e+0"
    ```

    * Number.prototype.toFixed() --参数范围也是(0-20)
        * 规则：
        1. 四舍六入
        2. 如果遇到5，就计算舍去和进位的值，分别与原值进行相减（差值的绝对值），最终比较 差值的绝对值，返回差值较小的那个（如果差值绝对值一样返回进位的那个）；
        ```js
        10.215.toFixed(2) // '10.21'
        // 先得到两个值 A=10.21 B=10.22

        // A-10.215=-0.004999999999999005
        // B-10.215=0.005000000000000782
        // 第一个差值绝对值较小 ,所以最后返回的是A 10.21
        ```
    * Number.prototype.toPrecision() --参数范围在(0-100)
        * 规则同toFixed(),不同点从左边第一个非0的数开始算起，toFixed()从小数点位置算起；

    * Number.prototype.toString() -- 参数在 2 到 36 之间，Number 对象`覆盖了 Object 对象上的 toString() 方法`，它不是继承的 Object.prototype.toString()。
    * Number.prototype.valueOf() --返回 Number 对象的原始值的数字；

### 小数转二进制

1. 了解js那些方法可以将数字进行 进制转换; --  radix支持 [2, 36] 之间的整数
    * Number.toString(radix);
    * parseInt(str,radix);
   
2. 深入了解 进制转换运算

    1. 小数转二进制

        * eg:3.01

        ```js
        Number(3.01).toString(2)
        // "11.0000001010001111010111000010100011110101110000101"
        ```

        1. 整数部分 --除2
            ```js
            3/2 --1
            1/2 --1
            ```
            * 终止条件商小于2

        2. 小数部分 --乘2
            ```js
            0.01 * 2 --> 0
            0.02 * 2 --> 0
            0.04 * 2 --> 0
            0.08 * 2 --> 0
            0.16 * 2 --> 0
            ```
            * 终止条件 小数部分为0

3. 二进制转小数

* 整数部分
    * 100
    * 1*2^2+0*2^1+0*2^0
* 小数部分
    * 0.0001111
    * 1*2^-4+1*2^-5+1*2^-6+1*2^-7


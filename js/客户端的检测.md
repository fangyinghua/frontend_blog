### 客户端的检测  ----第四版js高级程序设计 （十三章【笔记】）

* 能力检测
    * 最有效的场景是检测能力`是否存在`的同时,`验证`其是否`能够展现出预期的行为`。

    ```js
    //除了要检测是否存在 ，还要检测类型
    // 进行能力检测时应该尽量使用 typeof 操作符，但光有它还不够。尤其是某些宿主对象并不保证对 typeof 测试返回合理的值。
    function isSortable(object) {
        return typeof object.sort == "function";
    }
    ```
* 基于能力检测进行浏览器分析
    * 使用能力检测可以精准地分析运行代码的浏览器。
    * 使用`能力检测`而非`用户代理检测`的优点在于，`伪造用户代理字符串很简单`，而伪造能够欺骗`能力检测`的`浏览器特性`却很难。

    1. 检测特性
        可以按照能力将浏览器归类。如果你的应用程序需要使用特定的浏览器能力，那么`最好集中检测所有能力`，而不是等到用的时候再重复检测。

        ```js
        // 检测浏览器是否支持 Netscape 式的插件
        let hasNSPlugins = !!(navigator.plugins && navigator.plugins.length);

        // 检测浏览器是否具有 DOM Level 1 能力
        let hasDOM1 = !!(document.getElementById && document.createElement &&
                    document.getElementsByTagName);
        ```

    2. 检测浏览器
    根据`不同浏览器独有的行为`推断出浏览器的身份。  --（ 为了测试下面的方法，除了ie浏览器都安装了😁）

    ```js
      class BrowserDetector {
      constructor() {
        // 测试条件编译
        // IE6~10 支持
        this.isIE_Gte6Lte10 = /*@cc_on!@*/false;
        // 测试documentMode
        // IE7~11 支持
        this.isIE_Gte7Lte11 = !!document.documentMode;
        // 注意 要深入了解JavaScript能力检测，推荐阅读PeterMichaux的文章“FeatureDetection— State of the Art Browser Scripting”。
        // 测试 StyleMedia 构造函数
        // Edge 20 及以上版本支持 this.isEdge_Gte20 = !!window.StyleMedia;
        // 测试Firefox专有扩展安装API
        // 所有版本的 Firefox 都支持  -- 测试可以
        this.isFirefox_Gte1 = typeof InstallTrigger !== 'undefined';

        // 测试 chrome 对象及其 webstore 属性
        // Opera的某些版本有window.chrome，但没有window.chrome.webstore
        // 所有版本的 Chrome 都支持 --测试了window.chrome.webstore没有 只有window.chrome
        this.isChrome_Gte1 = !!window.chrome && !!window.chrome.webstore;

        // Safari 早期版本会给构造函数的标签符追加"Constructor"字样，如:
        // window.Element.toString(); // [object ElementConstructor]
        // Safari 3~9.1 支持
        this.isSafari_Gte3Lte9_1 = /constructor/i.test(window.Element);

        // 推送通知 API 暴露在 window 对象上
        // 使用默认参数值以避免对undefined调用toString() // Safari 7.1 及以上版本支持 this.isSafari_Gte7_1 = 测试可以
        (({pushNotification = {}} = {}) =>
        pushNotification.toString() == '[object SafariRemoteNotification]'
            )(window.safari);

        // 测试 addons 属性
        // Opera 20 及以上版本支持  测试了有window.opr ，没有window.opr.addons
        this.isOpera_Gte20 = !!window.opr && !!window.opr.addons;

        // 13.1 能力检测
        isIE() { return this.isIE_Gte6Lte10 || this.isIE_Gte7Lte11; }
        isEdge() { return this.isEdge_Gte20 && !this.isIE(); }
        isFirefox() { return this.isFirefox_Gte1; }
        isChrome() { return this.isChrome_Gte1; }
        isSafari() { return this.isSafari_Gte3Lte9_1 || this.isSafari_Gte7_1; }
        isOpera() { return this.isOpera_Gte20; }
    }
    ```

    * 改变浏览器用户代理 `__defineGetter__`

        ```js
        window.navigator.__defineGetter__('userAgent', () => 'foobar');
        window.navigator.__defineGetter__('vendor', () => 'vendor1');
        // ✨ 通过 __defineGetter__ 都可以更改navigator 所有属性
        ```

* 软件与硬件检测
    现代浏览器提供了一组`与页面执行环境`相关的信息，包括`浏览器、操作系统、硬件和周边设备信息`。 这些属性可以通过暴露在 `window.navigator` 上的一组 API 获得。不过，这些API的跨浏览器支持还不够好，远未达到标准化的程度。
    * 注意：强烈建议在`使用这些 API 之前`先 `检测它们是否存在`，因为其中多数都不是强制性的，且很多浏览器没有支持.

    1. 识别浏览器与操作系统
        1. navigator.oscpu
        2. navigator.vendor
            是一个字符串，通常包含浏览器开发商信息。
        3. navigator.platform
            是一个字符串，通常表示浏览器所在的操作系统。
        4. screen.colorDepth 和 screen.pixelDepth
            * screen.colorDepth和screen.pixelDepth返回一样的值，即显示器`每像素颜色的位深`。
            * CSS 对象模型(CSSOM)规范:
            screen.colorDepth 和 screen.pixelDepth 属性应该返回输出`设备中每像素`用于`显示颜色的位数`，`不包含 alpha 通道`。
        5. screen.orientation
        screen.orientation 属性返回一个 `ScreenOrientation 对象`，其中包含 Screen Orientation API 定义的屏幕信息。这里面最有意思的属性是 `angle 和 type`，前者返回相对于`默认状态下屏幕的角度`， 后者返回以下 4 种枚举值之一:
        
    2. 浏览器元数据
         navigator 对象暴露出一些 API，可以提供浏览器和操作系统的状态信息。
        1. Geolocation API
            * navigator.geolocation 属性暴露了 `Geolocation API`，可以让浏览器脚本感知`当前设备的地理位置`。这个API只`在安全执行环境`(通过 HTTPS 获取的脚本)中可用.
            * 这个 API 可以查询宿主系统并尽可能精确地返回设备的位置信息。
                * getCurrentPosition()
                * watchPosition()
                * clearWatch()
        2. Connection State 和 NetworkInformation API
            * Connection State
                * 浏览器会跟踪网络连接状态并以两种方式暴露这些信息:连接事件和 `navigator.onLine 属性`。在设备连接到网络时，浏览器会记录这个事实并在 window 对象上触发 online 事件。
                    ```js
                    const connectionStateChange = () => console.log(navigator.onLine);//返回一个boolean
                    window.addEventListener('online', connectionStateChange); window.addEventListener('offline', connectionStateChange);
                    ```
            * navigator 对象还暴露了 `NetworkInformation API`，可以通过 `navigator.connection` 属性使用:
                * downlink:整数，表示当前设备的带宽(以 Mbit/s 为单位)，舍入到最接近的 25kbit/s。
                * effectiveType:字符串枚举值，表示连接速度和质量。比如：4g/3g/2g
                * rtt:毫秒，表示当前网络实际的往返时间，舍入为最接近的 25 毫秒。
                * type:字符串枚举值，表示网络连接技术。
                    * bluetooth:蓝牙/ cellular:蜂窝。/ethernet:以太网。/none:无网络连接。相当于 navigator.onLine === false。/wifi:Wi-Fi。

        3. Battery Status API
            * 浏览器可以访问`设备电池及充电状态`的信息。navigator.getBattery()方法会返回一个Promise实例 

            ```js
            navigator.getBattery().then((b) => console.log(b));
            // BatteryManager { ... }
            ```      
            * BatteryManager 包含 4 个只读属性，提供了设备电池的相关信息。
                * charging:布尔值，表示设备当前是否正接入电源充电。如果设备没有电池，则返回 true。
                * chargingTime:整数，表示预计离电池充满还有多少秒。如果电池已充满或设备没有电池,返回0
                * dischargingTime:整数，表示预计离电量耗尽还有多少秒。如果设备没有电池，则返回 Infinity。
                * level:浮点数，表示电量百分比。电量完全耗尽返回 0.0，电池充满返回 1.0。如果设备没有电池，则返回 1.0。
                
            * 还提供了 4 个事件属性，可用于设置在相应的电池事件发生时调用的回调函数。
            ```js
            navigator.getBattery().then((battery) => {
                // 添加充电状态变化时的处理程序
                const chargingChangeHandler = () => console.log('chargingchange'); battery.onchargingchange = chargingChangeHandler;
                // 或
                battery.addEventListener('chargingchange', chargingChangeHandler);
                // 添加充电时间变化时的处理程序
                const chargingTimeChangeHandler = () => console.log('chargingtimechange'); battery.onchargingtimechange = chargingTimeChangeHandler;
                // 或
                battery.addEventListener('chargingtimechange', chargingTimeChangeHandler);
             
                // 添加放电时间变化时的处理程序 13 const dischargingTimeChangeHandler = () => console.log('dischargingtimechange'); battery.ondischargingtimechange = dischargingTimeChangeHandler;
                // 或
                battery.addEventListener('dischargingtimechange', dischargingTimeChangeHandler);
                // 添加电量百分比变化时的处理程序
                const levelChangeHandler = () => console.log('levelchange'); battery.onlevelchange = levelChangeHandler;
                // 或
                battery.addEventListener('levelchange', levelChangeHandler);
            });

            ```
        4.  硬件
            * 浏览器检测硬件的能力相当有限。不过，navigator 对象还是通过一些属性提供了基本信息。
                1. 处理器核心数
                    navigator.hardwareConcurrency 属性返回浏览器支持的逻辑处理器核心数量，包含表示核心数的一个整数值
                2. 设备内存大小
                    navigator.deviceMemory 属性返回设备大致的系统内存大小，包含单位为 GB 的浮点数。
                3. 最大触点数
                    navigator.maxTouchPoints 属性返回触摸屏支持的最大关联触点数量，包含一个整数值。
### 数据结构类型

* [队列]/[栈] 使用链表或者数组实现，用数组实现，需要处理扩容缩容的问题；

* 「图」两种表示方法：
    * 邻接表就是链表: -- 比较节省空间，但是时间上肯定不如邻接矩阵快
    * 邻接矩阵就是二维数组:  -- 邻接矩阵`判断连通性`迅速，并可以进行矩阵运算解决一些问题，但是一般比较耗费空间。

* 「散列表」
通过`散列函数`把`键` 映射 到一个`大数组里`. 
* 解决散列冲突的方法:
    * `拉链法`需要`链表`特性，操作简单，但需要空间；
    * `线性探查法`就需要`数组`特性，以便连续寻址，省空间，但操作稍微复杂些。
* 「树」
    * 用数组实现就是「堆」,因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；
    * 用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树

### 数据结构的操作,无非遍历 + 访问
* 如何遍历 + 访问？
    * 我们仍然从最高层来看，各种数据结构的遍历 + 访问无非两种形式，线性的和非线性的。
    * 线性就是 for/while 为代表，非线性就是递归为代表。

* 数组遍历框架，典型的线性遍历结构
```js
 for (int i = 0; i < arr.length; i++) {
        // 访问 arr[i]
    }
```

* 二叉树遍历框架，典型的非线性递归遍历结构：
```js
function traverse(root) {
    traverse(root.left)
    traverse(root.right)
}
```

* 链表遍历，兼具`线性和非线性遍历`结构：
```js
function traverse( head) {
    for ( p = head; p != null; p = p.next) {
        // 访问 p.val
    }
}

function traverse( head) {
    // 访问 head.val
    traverse(head.next)
}

```

* 二叉树又可以具体扩展为 N 叉树的遍历：
```js
function traverse( root) {
    for (child : root.children)
        traverse(child)
}
```

* `N 叉树的遍历`又可以扩展为`图的遍历`，因为，`图就是好几 N 叉棵树的结合体`。你说图是可能出现环的？
这个很好办，用个布尔数组 visited 做标记就行了.
